/* The codes below are generated by 'Element Studio'. */
#include <windows.h>
#include<Winsock2.h>
#pragma comment(lib,"Ws2_32.lib")
#define NETMSG_ACCEPT WM_USER + 0x1 
// declarations
long __stdcall WndProcdure(HWND hWnd, unsigned message, unsigned wParam, long lParam);
SOCKET sock_listen = INVALID_SOCKET;
// function defines
int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPreInstance, wchar_t * lpCmdLine, int iCmdShow)
{
	wchar_t szAppName[] = L"WinApp";
	WNDCLASSEX wcex = { 0 };
	wcex.cbSize = sizeof(wcex);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = &WndProcdure;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(GetStockObject(WHITE_BRUSH));
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = szAppName;
	wcex.hIconSm = wcex.hIcon;

	if (!RegisterClassEx(&wcex))
	{
		return -1;
	}

	//step 0:≥ı ºªØWinsockø‚
	WSADATA wsaData;
	if (WSAStartup(MAKEWORD(2, 2), &wsaData) != 0)
		return -1;

	//step 1:create a socket
	sock_listen = ::socket(AF_INET, SOCK_STREAM, 0);
	if (sock_listen == INVALID_SOCKET)
		return -1;

	//step 2:bind to a local address and port
	//fill out the structure of address
	struct sockaddr_in local_addr = { 0 };
	local_addr.sin_family = AF_INET;
	local_addr.sin_port = (htons(2049));
	local_addr.sin_addr.S_un.S_addr = ::inet_addr("192.168.0.20");
	int result = ::bind(sock_listen,
		reinterpret_cast<const struct sockaddr*>(&local_addr),
		sizeof(local_addr));

	if (result == SOCKET_ERROR)
		return -1;


	//step 3:listen
	result = ::listen(sock_listen, SOMAXCONN);
	if (result == SOCKET_ERROR)
		return -1;

	struct sockaddr_in client_addr = { 0 };
	int len = sizeof(client_addr);
	
	

	HWND hWnd = NULL;
	hWnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW, szAppName, L"App", WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL);
	ShowWindow(hWnd, iCmdShow);
	UpdateWindow(hWnd);
	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}
	return msg.wParam;
}
long __stdcall WndProcdure(HWND hWnd, unsigned message, unsigned wParam, long lParam)
{
	HDC hDC = NULL;
	PAINTSTRUCT ps;
	switch (message)
	{
	case WM_CREATE:
	{
		if (::WSAAsyncSelect(sock_listen, hWnd, NETMSG_ACCEPT, FD_ACCEPT) != 0)
			::MessageBox(hWnd,L"AsyncSelect Error",L"caption,",MB_OK);
		return 0;
	}
	case WM_PAINT:
	{
		hDC = BeginPaint(hWnd, &ps);
		EndPaint(hWnd, &ps);
		return 0;
	}
	case WM_DESTROY:
	{
		PostQuitMessage(0);
		return 0;
	}
	}
	return DefWindowProc(hWnd, message, wParam, lParam);
}

