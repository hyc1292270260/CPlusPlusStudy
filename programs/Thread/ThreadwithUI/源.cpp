/* The codes below are generated by 'Element Studio'. */
#include <windows.h>
#include "resource.h"
#include <Commctrl.h>
#include <thread>
#include <chrono>

// declarations
long __stdcall WndProcdure(HWND hWnd, unsigned message, unsigned wParam, long lParam);
int __stdcall DlgProcedure(HWND hDlg, unsigned message, unsigned wParam, long lParam);

// function defines
int __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPreInstance, wchar_t * lpCmdLine, int iCmdShow)
{
	wchar_t szAppName[] = L"WinApp";
	WNDCLASSEX wcex = { 0 };
	wcex.cbSize = sizeof(wcex);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = &WndProcdure;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(GetStockObject(WHITE_BRUSH));
	wcex.lpszMenuName = NULL;
	wcex.lpszClassName = szAppName;
	wcex.hIconSm = wcex.hIcon;
	if (!RegisterClassEx(&wcex))
	{
		return -1;
	}

	HWND hWnd = NULL;
	//DialogBox(hInstance, reinterpret_cast<const wchar_t*>(IDD_DIALOG1), nullptr, DlgProcedure);//强制响应对话框
	hWnd = CreateDialog(hInstance, reinterpret_cast<const wchar_t*>(IDD_DIALOG1), nullptr, DlgProcedure);

	ShowWindow(hWnd, iCmdShow);
	UpdateWindow(hWnd);

	hWnd = CreateWindowEx(WS_EX_OVERLAPPEDWINDOW,
		szAppName,
		L"App",
		WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT,
		0,
		CW_USEDEFAULT,
		0,
		HWND_MESSAGE,
		NULL,
		hInstance,
		NULL);

	ShowWindow(hWnd, iCmdShow);
	UpdateWindow(hWnd);

	MSG msg;
	while (GetMessage(&msg, NULL, 0, 0))
	{
		TranslateMessage(&msg);
		DispatchMessage(&msg);
	}

	return msg.wParam;
}

long __stdcall WndProcdure(HWND hWnd, unsigned message, unsigned wParam, long lParam)
{
	HDC hDC = NULL;
	PAINTSTRUCT ps;
	switch (message)
	{
	case WM_CREATE:
	{
		return 0;
	}
	case WM_PAINT:
	{
		hDC = BeginPaint(hWnd, &ps);
		EndPaint(hWnd, &ps);
		return 0;
	}
	case WM_DESTROY:
	{
		PostQuitMessage(0);
		return 0;
	}
	}
	return DefWindowProc(hWnd, message, wParam, lParam);
}

/*HANDLE h_ExitEvent = nullptr;
HANDLE h_begin_1 = nullptr;
HANDLE h_event_1to2 = nullptr;
HANDLE h_event_2to3 = nullptr;

HWND h_thread1 = nullptr;
HWND h_thread2 = nullptr;
HWND h_thread3 = nullptr;

int __stdcall
DlgProcedure(HWND hDlg, unsigned message, unsigned wParam, long lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
	{
		h_thread1 = ::GetDlgItem(hDlg, IDC_PROGRESS1);
		h_thread2 = ::GetDlgItem(hDlg, IDC_PROGRESS2);
		h_thread3 = ::GetDlgItem(hDlg, IDC_PROGRESS3);

		::PostMessage(h_thread1, PBM_SETRANGE, NULL, MAKELPARAM(0, 100)); // range.
		::PostMessage(h_thread1, PBM_SETPOS, 0, NULL); // set the new position.
		::PostMessage(h_thread1, PBM_SETSTEP, 1, NULL); // step.

		::PostMessage(h_thread2, PBM_SETRANGE, NULL, MAKELPARAM(0, 100)); // range.
		::PostMessage(h_thread2, PBM_SETPOS, 33, NULL); // set the new position.
		::PostMessage(h_thread2, PBM_SETSTEP, 1, NULL); // step.

		::PostMessage(h_thread3, PBM_SETRANGE, NULL, MAKELPARAM(0, 100)); // range.
		::PostMessage(h_thread3, PBM_SETPOS, 66, NULL); // set the new position.
		::PostMessage(h_thread3, PBM_SETSTEP, 1, NULL); // step.

		h_begin_1 = ::CreateEvent(nullptr, true, false, nullptr);
		h_ExitEvent = ::CreateEvent(nullptr, true, false, nullptr);
		h_event_1to2 = ::CreateEvent(nullptr, true, false, nullptr);
		h_event_2to3 = ::CreateEvent(nullptr, true, false, nullptr);

		return false;
	}
	case WM_CLOSE:
	{
		EndDialog(hDlg, 0);
		return true;
	}
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case  IDC_BUTTON1 :
				
		{
			//for (int i = 0; i < 100; ++i)
			//{
			//	::Sleep(100);
			//	::SendMessage(h_thread1, PBM_STEPIT, NULL, NULL);
			//}
			std::thread t1([](void) mutable -> void
			{
				HANDLE a[] = { h_ExitEvent, h_begin_1 };
				while (true)
				{
					//::ResetEvent(h_event_1to2);
					::PostMessage(h_thread1, PBM_SETPOS, 0, NULL); // set the new position.
					for (int i = 0; i < 33; ++i)
					{
						unsigned index = ::WaitForMultipleObjects(2, a, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;
						//::WaitForSingleObject(h_begin_1, INFINITE);
						//::Sleep(100);
						std::this_thread::sleep_for(std::chrono::milliseconds(100));
						::SendMessage(h_thread1, PBM_STEPIT, NULL, NULL);
					}

					::SetEvent(h_event_1to2);
				}
			});

			std::thread t2([](void) mutable -> void
			{
				HANDLE a[] = { h_ExitEvent, h_begin_1 };
				HANDLE b[] = { h_ExitEvent, h_event_1to2 };
				while (true)
				{
					//::ResetEvent(h_event_2to3);
					::PostMessage(h_thread2, PBM_SETPOS, 33, NULL); // set the new position.
					for (int i = 0; i < 33; ++i)
					{
						unsigned index = ::WaitForMultipleObjects(2, a, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;

						index = ::WaitForMultipleObjects(2, b, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;

						if (i == 32)
						{
							::ResetEvent(h_event_1to2);
						}

						std::this_thread::sleep_for(std::chrono::milliseconds(100));
						::SendMessage(h_thread2, PBM_STEPIT, NULL, NULL);
					}

					::SetEvent(h_event_2to3);
				}
			});


			std::thread t3([](void) mutable -> void
			{
				HANDLE a[] = { h_ExitEvent, h_begin_1 };
				HANDLE b[] = { h_ExitEvent, h_event_2to3 };
				while (true)
				{
					::PostMessage(h_thread3, PBM_SETPOS, 66, NULL); // set the new position.
					for (int i = 0; i < 34; ++i)
					{
						unsigned index = ::WaitForMultipleObjects(2, a, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;

						index = ::WaitForMultipleObjects(2, b, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;

						if (i == 33)
						{
							::ResetEvent(h_event_2to3);
						}

						std::this_thread::sleep_for(std::chrono::milliseconds(100));
						::SendMessage(h_thread3, PBM_STEPIT, NULL, NULL);
					}
				}
			});

			//HANDLE h_thread = t1.native_handle();
			//TerminateThread(h_thread, 1);
			t1.detach();
			t2.detach();
			t3.detach();

			return true;
		}
		case  IDC_BUTTON2:
		{
			::SetEvent(h_ExitEvent);
			return true;
		}
		case IDCANCEL:
		{
			::ResetEvent(h_begin_1);
			return true;
		}
		case IDOK:
		{
			::SetEvent(h_begin_1);
			return true;
		}
		}
		return false;
	}
	}
	return false;
}
*/

HANDLE h_ExitEvent = nullptr;
HANDLE h_begin_1 = nullptr;
HANDLE h_event_1to2 = nullptr;
HANDLE h_event_2to3 = nullptr;

HANDLE h_semaphore = nullptr;

HWND h_thread1 = nullptr;
HWND h_thread2 = nullptr;
HWND h_thread3 = nullptr;

int __stdcall
DlgProcedure(HWND hDlg, unsigned message, unsigned wParam, long lParam)
{
	switch (message)
	{
	case WM_INITDIALOG:
	{
		h_thread1 = ::GetDlgItem(hDlg, IDC_PROGRESS1);
		h_thread2 = ::GetDlgItem(hDlg, IDC_PROGRESS2);
		h_thread3 = ::GetDlgItem(hDlg, IDC_PROGRESS3);

		//投递，不一定立即执行
		::PostMessage(h_thread1, PBM_SETRANGE, NULL, MAKELPARAM(0, 100)); // range.
		::PostMessage(h_thread1, PBM_SETPOS, 0, NULL); // set the new position.
		::PostMessage(h_thread1, PBM_SETSTEP, 1, NULL); // step.

		::PostMessage(h_thread2, PBM_SETRANGE, NULL, MAKELPARAM(0, 100)); // range.
		::PostMessage(h_thread2, PBM_SETPOS, 33, NULL); // set the new position.
		::PostMessage(h_thread2, PBM_SETSTEP, 1, NULL); // step.

		::PostMessage(h_thread3, PBM_SETRANGE, NULL, MAKELPARAM(0, 100)); // range.
		::PostMessage(h_thread3, PBM_SETPOS, 66, NULL); // set the new position.
		::PostMessage(h_thread3, PBM_SETSTEP, 1, NULL); // step.

		h_begin_1 = ::CreateEvent(nullptr, true, false, nullptr);
		h_ExitEvent = ::CreateEvent(nullptr, true, false, nullptr);
		h_event_1to2 = ::CreateEvent(nullptr, true, false, nullptr);
		h_event_2to3 = ::CreateEvent(nullptr, true, false, nullptr);  //手动重置，初始无信号
		h_semaphore = ::CreateSemaphore(nullptr, 1, 1, nullptr);

		return false;
	}
	case WM_CLOSE:
	{
		EndDialog(hDlg, 0);
		return true;
	}
	case WM_COMMAND:
	{
		switch (LOWORD(wParam))
		{
		case IDC_BUTTON1:  //start
		{
			std::thread t1([](void) mutable -> void
			{
				HANDLE a[] = { h_ExitEvent, h_begin_1 };
				while (true)
				{
					::PostMessage(h_thread1, PBM_SETPOS, 0, NULL); // set the new position.
					//::WaitForSingleObject(h_begin_1, INFINITE);
					for (int i = 0; i < 33; ++i)
					{
						//如果此参数为TRUE，则在lpHandles数组中的所有对象的状态发出信号时返回该函数。
						//如果为FALSE，则当任何一个对象的状态设置为发信号时，该函数返回。
						//在后一种情况下，返回值表示其状态导致函数返回的对象。
						//如果bWaitAll为TRUE，则返回值表示发出所有指定对象的状态。
						//如果bWaitAll为FALSE，则返回值减去WAIT_OBJECT_0表示满足等待的对象的lpHandles数组索引。
						//如果在调用期间发出多个对象的信号，则这是具有所有信号对象的索引值最小的信号对象的数组索引。
						unsigned index = ::WaitForMultipleObjects(2, a, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;
						std::this_thread::sleep_for(std::chrono::milliseconds(100));
						::SendMessage(h_thread1, PBM_STEPIT, NULL, NULL);       //直接取消息
					}
					::SetEvent(h_event_1to2);
					//::ReleaseSemaphore(h_semaphore, 1, nullptr);
				}
			});

			std::thread t2([](void) mutable -> void
			{
				HANDLE a[] = { h_ExitEvent,h_begin_1 };
				HANDLE b[] = { h_ExitEvent,h_event_1to2 };
				while (true)
				{
					::PostMessage(h_thread2, PBM_SETPOS, 33, NULL); // set the new position.
					//::WaitForSingleObject(h_semaphore, INFINITE);		
					for (int i = 0; i < 33; ++i)
					{	
						unsigned index = ::WaitForMultipleObjects(2, a, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;
						index = ::WaitForMultipleObjects(2, b, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;
						if (i == 32)
							::ResetEvent(h_event_1to2);
						std::this_thread::sleep_for(std::chrono::milliseconds(100));
						::SendMessage(h_thread2, PBM_STEPIT, NULL, NULL);
					}

					//::ReleaseSemaphore(h_semaphore, 1, nullptr);
					::SetEvent(h_event_2to3);
				}
			});


			std::thread t3([](void) mutable -> void
			{
				HANDLE a[] = { h_ExitEvent, h_begin_1 };
				HANDLE b[] = { h_ExitEvent,h_event_2to3 };
				while (true)
				{
					//::WaitForSingleObject(h_semaphore, INFINITE);
					::PostMessage(h_thread3, PBM_SETPOS, 66, NULL); // set the new position.
					for (int i =0; i < 34; ++i)
					{
						unsigned index = ::WaitForMultipleObjects(2, a, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;
						 index = ::WaitForMultipleObjects(2, b, false, INFINITE);
						if (index - WAIT_OBJECT_0 == 0)
							return;
						if (i == 33)
							::ResetEvent(h_event_2to3);
						std::this_thread::sleep_for(std::chrono::milliseconds(100));
						::SendMessage(h_thread3, PBM_STEPIT, NULL, NULL);
					}

					//::ReleaseSemaphore(h_semaphore, 1, nullptr);
				}
			});

			/*HANDLE h_thread = t1.native_handle();   //强制退出
			TerminateThread(h_thread, 1);*/
			t1.detach();
			t2.detach();
			t3.detach();

			return true;
		}
		case IDC_BUTTON2:					//退出
		{
			::SetEvent(h_ExitEvent);
			return true;
		}
		case IDCANCEL:
		{
			::ResetEvent(h_begin_1);		//stop无信号
			return true;
		}
		case IDOK:							//open有信号
		{
			::SetEvent(h_begin_1);
			return true;
		}
		}
		return false;
	}
	}
	return false;
}
//主线程控制UI
//右键->添加资源